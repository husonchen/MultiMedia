/***
    This program is for the CSIT5110 Assignment.

    Basic -
        The program generates, plays and shows on the screen all or part of a single 5 second sound.
        The variables 'frequency' (the fundamental frequency), 'sound' (the choice of sound being
        generated) and 'postprocesses' (the post-processings being applied) control the frequency,
        the type of sound that is generated and the post-processings that are applied to the sound.
        If you want to, these parameters can be interactively changed by the coresponding
        GUI controls (the 'Sound Controls'). This may or may not be useful to you.
        You can click on the 'Play Sound' button to listen to the sounds with the currently
        selected paramenters. You can click on the 'Stop Sound' button to stop the currently
        playing sound if you want to.
        The sound of the currently selected parameters is saved into a WAV file called 'currentsound.wav'.

    The 'Make All Sounds and Play' button -
        When you click on the 'Make all sounds and play' button the program generates all of
        the 19 individual sounds, one after another, and saves the result in 'allsounds.wav'
        (saved in the processing program directory). It also plays the sounds after generation
        is completed.
        With the starting code, when you press this button the program makes just one sound
        and saves it. So you need to improve the program so that all the 19 individual sounds
        are generated, one after another.
        Generate one example of each individual sound. This is useful for you (and us) to
        check that your sounds are being generated correctly. You can use an audio editor
        such as Audacity to view them.

    The 'Select MIDI, Convert and Play' button -
        When you click on the 'Select MIDI, Convert and Play' button the program generates a
        series of musical notes, puts them together to make a music, applies an echo algorithm
        to the entire music, and saves the result in 'allmusic.wav' (saved in the processing
        program directory). After the generation is completed, it plays the generated msuic for once.
        You need to improve the program so that lots of sounds are generated and added to the
        music at appropriate starting times, to make the melody from your selected MIDI song.

    See the assignment instructions for more exact information and guidelines.

    DR
***/

import java.io.*;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import javax.sound.midi.MidiSystem;
import javax.sound.midi.Sequence;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.Track;
import controlP5.*;
import ddf.minim.*;

int totalSoundGenerators = 24;  // Total number of individual sounds that can be generated by this program
int totalSoundNeedToBeGenerated = 19; // Total number of individual sounds that needed to be generated

/***
    Individual sound generation:
        ***** The following audio generation functions are given to you *****
        (1) sine
        (2) square wave (time domain method)
        (3) square wave (additive method)
        (4) sawtooth wave (time domain method)

        ***** You must complete the following audio generation functions *****
        (5) sawtooth wave (additive method)
        (6) triangle wave (additive method)
        (7) bell sound (FM synthesis method)
        (8) Karplus-Strong algorithm string sound (time domain method)
        (9) white noise (time domain method)
        (10) Repeating Narrow Pulse (time domain method)
        (11) 3 sine wave sound (additive method)
        (12) triangle wave (time domain method)
        (13) science fiction movie sound
        (14) Karplus-Strong non-string sound
        (15) sound 1 multiply with sound 1
        (16) sound 1 multiply with sound 5
        (17) sound 1 multiply with sound 10
        (18) sound 4 multiply with sound 4
        (19) sound 5 multiply with sound 6
***/
int sound = 2; // Say which sound you want to generate in the range 1-24, see list above

/***
    Post-processing of an individual sound:
        ***** The following post processing functions are given to you *****
        (1) no change to sound
        (2) exponential decay fade out

        ***** You must complete the following post processing functions *****
        (3) low pass filter  - if your student id ends in an odd number
        (4) band reject filter - if your student id ends in an even number
        (5) linear fade in - all students
        (6) reverse - all students
        (7) boost - all students
        (8) tremolo effect - all students
        (9) echo - all students
***/
int[] postprocesses = {2, 1, 1, 7};   // Which post-Processing you want, see list above

/***
    Functions to look at:

        In SoundGenerator.pde:
            - You need to make sure all 19 individual sounds are correctly generated.
            - Remember that 'frequency' is a control variable (in other words, if the user clicks on the
              window to change the value of 'frequency', the generated sound will change appropriately).
            - The only exception to this is any FM sound, where the value of frequency is fixed.

        In AudioSamples.pde:
            - You need to make sure the various post processing algorithms (listed above) is working correctly.

        In TrackGenerator.pde:
            - You have to complete the function MIDIPitchToFrequency() so it convert a MIDI pitch number (0-127)
              into the actual frequency, in Hz

        In generateSoundSequence():
            - All 19 individual sounds are generated and added to the 57 second output sequence at
              appropriate times, so each sound can be clearly heard.
            - Do not apply echo to this 19 sound sequence (because it would make it harder for you / us
              to check your individual sounds)
            - The sound sequence will be saved as a WAV file; please submit it

        In generateMusic():
            - Lots of individual sounds are generated, appropriate post-processing applied, and the sounds are added
              to the music sequence at appropriate starting times, to make a series of notes (i.e. a music track).
            - Apply appropriate post-processing to the notes so that they sound good/great.
            - After the notes have all been generated and added, apply echo to the final music sequence so
              it sounds more interesting.
            - The music sequence will be saved as a WAV file; please submit it

        Function setup()
            - This sets up the program. It is executed once. You don't need to change it.

        Function draw()
            - This is repeatedly executed many times each second. You don't need to change it.
***/

boolean showDebugMessages = false; // Change this to true when you are developing, and false before you submit your assignment

int samplingRate = 44100; // Number of samples used for 1 second of sound (fixed, don't change)
float nyquistFrequency = samplingRate / 2.0;

// Minim is used to handle sound playback
Minim minim;
AudioPlayer masterAudioPlayer;

float singleSoundDuration = 5; // The duration of the single sound (in seconds)
AudioSamples singleSoundSamples; // For storing the sound samples for a single sound

float soundSequenceDuration = totalSoundNeedToBeGenerated * 3; // The duration of the 19-sound sequence (in seconds)
AudioSamples soundSequenceSamples; // For storing the 19-sound samples

float musicDuration = 30;  // The duration of the complete sound sequence (in seconds)
AudioSamples musicSamples; // For storing the music sequence samples of several sound

boolean playingSingleSound = false; // Flag, to know what is being played
boolean playingSoundSequence = false; // Flag, to know what is being played
boolean playingMusic = false; // Flag, to know what is being played

boolean writingSingleSound = false; // Flag, to ensure we don't try to do something while the single sound is being generated
boolean writingSoundSequence = false; // Flag, to ensure we don't try to do something while the sound sequence is being generated
boolean writingMusic = false; // Flag, to ensure we don't try to do something while the music sequence is being generated
boolean individualSoundWritten = false; // Flag, used to ensure individual sound is only created once

float amp = 1.0;  // Sound amplitude control, with a arbitrary default value
float maxValue = 1.0;  // Maximum sample value, in the system we use it is 1.0 (don't change)
float minValue = -1.0; // Minimum sample value, in the system we use it is -1.0 (don't change)

float frequency = 256;   // Freqency to use when generating an individual sound, with an arbitrary default value
float minFrequency = 20;  // Lowest possible frequency
float maxFrequency = 5000;  // Highest possible frequency

// The primary sound generator used by the GUI
SoundGenerator soundGenerator = new SoundGenerator(sound, amp, frequency, singleSoundDuration, samplingRate);

/*** GUI related variables ***/
boolean initializing = true;

ControlP5 cp5; // Main GUI controls

// Variables for display window size
int windowWidth = 1080; // Pixels
int windowHeight = 720; // Pixels

Slider frequencySelectionSlider;    // Slider to choose the frequency
RadioButton soundSelectionRadioButton; // Radio button to choose the sound
RadioButton[] postprocessSelectionRadioButton = new RadioButton[postprocesses.length]; // Radio buttons to choose the postprocessings
Button zoomInButton;
Button zoomOutButton;
Textlabel soundLabel;
Textlabel[] postProcessingLabel = new Textlabel[postprocesses.length];
Textlabel zoomLabel;
Textlabel oneLeft;
Textlabel zeroLeft;
Textlabel minusOneLeft;
Textlabel oneRight;
Textlabel zeroRight;
Textlabel minusOneRight;
Textlabel oneBoth;
Textlabel zeroBoth;
Textlabel minusOneBoth;
Textlabel leftChannel;
Textlabel rightChannel;

int screenHeight = 160; // The distance of the 1 and -1 line from the middle0
int offset = 90;

int middle0 = windowHeight / 2 - offset; // The y position of the 0 line of the sound display
int upperBound = middle0 - screenHeight;
int lowerBound = middle0 + screenHeight;

int gapScreen = 10;
int screenHeightHalf = (screenHeight - gapScreen) / 2;

int middle0Left = middle0 - gapScreen / 2 - screenHeightHalf; // The y position of the 0 line of the music display for left channel
int upperBoundLeft = middle0Left - screenHeightHalf;
int lowerBoundLeft = middle0Left + screenHeightHalf;

int middle0Right = middle0 + gapScreen + screenHeightHalf; // The y position of the 0 line of the music display for right channel
int upperBoundRight = middle0Right - screenHeightHalf;
int lowerBoundRight = middle0Right + screenHeightHalf;

int zoom = 2; // Zoom level
int zoomStep = 2; // Ratio between two zoom level
int minZoom = 1;
int maxZoom = 256;

int gapPlot = 65; // Various spacing control of the GUI elements
int gapControls = 30;

int soundControlHeight = 230;
int soundControlWidth = 720;

int normal = 0xFFFFFFFF; // Color stlye of the GUI contorls
int highlighted = 0xFFFF9900;

/*** End of GUI related variables ***/

//////////////////////////////////////////////////////////////////////////////

// This method is called only at initialization
void setup() {
    // Specify the window size
    size(1080, 720, P2D); // Processing 3 only allow using non-Variable in the size() function
    minim = new Minim(this);

    singleSoundSamples = new AudioSamples(singleSoundDuration, samplingRate);
    soundSequenceSamples = new AudioSamples(soundSequenceDuration, samplingRate);
    musicSamples = new AudioSamples(musicDuration, samplingRate);

    if(showDebugMessages) {
        println();
        println(">>>  A single sound will be generated.");
        println(">>>  For that sound you can click on the GUI controls to change the parameters.");
        println(">>>  This can be useful as a quick way to explore some of the sounds your program can generate.");
    }

    cp5 = new ControlP5(this);

    cp5.addTextlabel("label0").setText("CSIT5110 Audio Generator").setPosition(0, 15).setFont(createFont("Arial", 36)).getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

    cp5.addTextlabel("label1").setText("Frequency").setPosition(37, lowerBoundRight + gapPlot).setFont(createFont("Arial", 14));
    cp5.addTextlabel("label2").setText("Sound").setPosition(62, lowerBoundRight + gapPlot + gapControls).setFont(createFont("Arial", 14));
    cp5.addTextlabel("label3").setText("Post-Process 1").setPosition(12, lowerBoundRight + gapPlot + 3 * gapControls).setFont(createFont("Arial", 14));
    cp5.addTextlabel("label4").setText("Post-Process 2").setPosition(12, lowerBoundRight + gapPlot + 4 * gapControls).setFont(createFont("Arial", 14));
    cp5.addTextlabel("label5").setText("Post-Process 3").setPosition(12, lowerBoundRight + gapPlot + 5 * gapControls).setFont(createFont("Arial", 14));
    cp5.addTextlabel("label6").setText("Post-Process 4").setPosition(12, lowerBoundRight + gapPlot + 6 * gapControls).setFont(createFont("Arial", 14));

    cp5.addTextlabel("label7").setText("Time Domain Display of:").setPosition(0, upperBoundLeft - 48).setColor(0xffffffff).setFont(createFont("Arial", 18));
    soundLabel = cp5.addTextlabel(" Sine (Time domain method)").setPosition(0, upperBoundLeft - 28).setColor(0xffffffff).setFont(createFont("Arial", 18));

    oneBoth = cp5.addTextlabel("label8").setText("1").setPosition(width - 12, upperBound - 8).setFont(createFont("Arial", 12));
    zeroBoth = cp5.addTextlabel("label9").setText("0").setPosition(width - 12, middle0 - 8).setFont(createFont("Arial", 12));
    minusOneBoth = cp5.addTextlabel("label10").setText("-1").setPosition(width - 16, lowerBound - 8).setFont(createFont("Arial", 12));
    minusOneBoth.getCaptionLabel().align(ControlP5.RIGHT, ControlP5.BOTTOM);

    oneLeft = cp5.addTextlabel("label11").setText("1").setPosition(width - 12, upperBoundLeft - 8).setFont(createFont("Arial", 12));
    zeroLeft = cp5.addTextlabel("label12").setText("0").setPosition(width - 12, middle0Left - 8).setFont(createFont("Arial", 12));
    minusOneLeft = cp5.addTextlabel("label13").setText("-1").setPosition(width - 16, lowerBoundLeft - 8).setFont(createFont("Arial", 12));
    minusOneLeft.getCaptionLabel().align(ControlP5.RIGHT, ControlP5.BOTTOM);
    leftChannel = cp5.addTextlabel("label14").setText("Left").setPosition(4, upperBoundLeft).setFont(createFont("Arial", 14));

    oneRight = cp5.addTextlabel("label15").setText("1").setPosition(width - 12, upperBoundRight - 8).setFont(createFont("Arial", 12));
    zeroRight = cp5.addTextlabel("label16").setText("0").setPosition(width - 12, middle0Right - 8).setFont(createFont("Arial", 12));
    minusOneRight = cp5.addTextlabel("label17").setText("-1").setPosition(width - 16, lowerBoundRight - 8).setFont(createFont("Arial", 12));
    minusOneRight.getCaptionLabel().align(ControlP5.RIGHT, ControlP5.BOTTOM);
    rightChannel = cp5.addTextlabel("label18").setText("Right").setPosition(4, upperBoundRight).setFont(createFont("Arial", 14));

    for(int i = 0; i < postprocesses.length; ++i) {
        postProcessingLabel[i] = cp5.addTextlabel("labelpp" + str(i)).setText("No post-Processing").setPosition(570, lowerBound + gapPlot + (i + 3) * gapControls + 2).setFont(createFont("Arial", 14));
    }
    updatePostprocessingInfo(postProcessingLabel[0], 2);

    zoomLabel = cp5.addTextlabel("label23").setText("Zoom: 2x").setPosition(width - 140, lowerBound + 12).setFont(createFont("Arial", 14));

    cp5.addTextlabel("label24").setText("Sound Controls").setPosition(10, lowerBound + 41).setColor(0xffffffff).setFont(createFont("Arial", 20));

    frequencySelectionSlider = cp5.addSlider("")
    .setPosition(115, lowerBound + gapPlot)
    .setSize(500, 20)
    .setRange(minFrequency, maxFrequency)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted);
    frequencySelectionSlider.setValue(frequency).setDecimalPrecision(1);
    frequencySelectionSlider.getValueLabel().toUpperCase(false).setFont(createFont("Arial", 14)).align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER);
    frequencySelectionSlider.setValueLabel(Math.floor(frequencySelectionSlider.getValue() * 10) / 10 + " Hz");

    soundSelectionRadioButton = cp5.addRadioButton("soundSelectionRadioButton")
    .setPosition(115, lowerBound + gapPlot + gapControls)
    .setSize(18, 18)
    .setItemsPerRow(totalSoundGenerators / 2)
    .setSpacingColumn(33)
    .setSpacingRow(5)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .setNoneSelectedAllowed(false);

    for(int i = 1; i <= totalSoundGenerators; ++i) {
        soundSelectionRadioButton.addItem("s"+str(i), i);
    }

    for(Toggle t:soundSelectionRadioButton.getItems()) {
        t.getCaptionLabel().setFont(createFont("Arial", 14, true));
    }

    soundSelectionRadioButton.activate(sound - 1);

    for(int i = 0; i < postprocesses.length; ++i) {
        postprocessSelectionRadioButton[i] = cp5.addRadioButton("postprocessSelectionRadioButton" + str(i))
        .setPosition(115, lowerBound + gapPlot + (i + 3) * gapControls)
        .setSize(18, 18)
        .setItemsPerRow(10)
        .setSpacingColumn(33)
        .setColorBackground(normal)
        .setColorForeground(highlighted)
        .setColorActive(highlighted)
        .setNoneSelectedAllowed(false);

        for(int j = 1; j < 10; ++ j) {
            postprocessSelectionRadioButton[i].addItem("p" + str(i) + str(j), j);
        }

        int j = 0;
        for(Toggle t:postprocessSelectionRadioButton[i].getItems()) {
            t.getCaptionLabel().setFont(createFont("Arial", 14, true));
            t.getCaptionLabel().setText("P" + str(++j));
        }

        postprocessSelectionRadioButton[i].activate(postprocesses[i] - 1);
    }

    // Create a button and put it near the right-Bottom corner
    cp5.addButton(cp5, "playSound", "Play Sound", 2)
    .setPosition(width - 320, lowerBound + gapPlot)
    .setSize(140, 30)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(writingSingleSound || writingSoundSequence || writingMusic) return;
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                if (!individualSoundWritten) {
                    regenerateSingleSound();
                }
                if(masterAudioPlayer != null) {
                    masterAudioPlayer.pause();
                    masterAudioPlayer.rewind();
                    masterAudioPlayer.play();
                    playingSingleSound = true;
                }
            }
        }
    })
    .getCaptionLabel().toUpperCase(false).setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    // Create a button and put it near the right-Bottom corner
    cp5.addButton(cp5, "stopSound", "Stop Sound", 3)
    .setPosition(width - 160, lowerBound + gapPlot)
    .setSize(140, 30)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                if(masterAudioPlayer != null) {
                    masterAudioPlayer.pause();
                    masterAudioPlayer.rewind();
                }
            }
        }
    })
    .getCaptionLabel().toUpperCase(false).setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    // Create a button and put it near the right-Bottom corner
    cp5.addButton(cp5, "makesound", "Make All Sounds and Play", 0)
    .setPosition(width - 320, lowerBound + gapPlot + 3 * gapControls)
    .setSize(300, 30)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(writingSingleSound || writingSoundSequence || writingMusic) return;
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                generateSoundSequence();
            }
        }
    })
    .getCaptionLabel().toUpperCase(false).setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    // Create a button and put it near the right-Bottom corner
    cp5.addButton(cp5, "generateMusic", "Select MIDI, Convert and Play", 1)
    .setPosition(width - 320, lowerBound + gapPlot + 4.5 * gapControls)
    .setSize(300, 30)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(writingSingleSound || writingSoundSequence || writingMusic) return;
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                selectInput("Select a music file:", "generateMusic");
            }
        }
    })
    .getCaptionLabel().toUpperCase(false).setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    // Zoom In
    zoomInButton = cp5.addButton(cp5, "zoomIn", "-", 4)
    .setPosition(width - 30, lowerBound + 10)
    .setSize(20, 20)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                zoom *= zoomStep;
                if(zoom > maxZoom) zoom = maxZoom;
                zoomLabel.setText("Zoom: " + str(zoom) + "x");
            }
        }
    });
    zoomInButton.getCaptionLabel().setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    // Zoom Out
    zoomOutButton = cp5.addButton(cp5, "zoomOut", "+", 5)
    .setPosition(width - 55, lowerBound + 10)
    .setSize(20, 20)
    .setColorBackground(normal)
    .setColorForeground(highlighted)
    .setColorActive(highlighted)
    .addCallback(new CallbackListener() {
        public void controlEvent(CallbackEvent theEvent) {
            if(theEvent.getAction() == ControlP5.ACTION_RELEASED) {
                zoom /= zoomStep;
                if(zoom < minZoom) zoom = minZoom;
                zoomLabel.setText("Zoom: " + str(zoom) + "x");
            }
        }
    });
    zoomOutButton.getCaptionLabel().setColor(0).setFont(createFont("Arial", 16, true)).align(ControlP5.CENTER, ControlP5.CENTER);

    initializing = false;

    regenerateSingleSound();
}

// This method handle the displayed sound information
void updateSoundInfo() {
    String result = "";

    switch(sound) {
        case 1: result = "Sine (Time Domain Method)"; break;
        case 2: result = "Square (Time Domain Method)"; break;
        case 3: result = "Square (Additive Synthesis)"; break;
        case 4: result = "Sawtooth (Time Domain Method)"; break;
        case 5: result = "Sawtooth (Additive Synthesis)"; break;
        case 6: result = "Triangle (Additive Synthesis)"; break;
        case 7: result = "Bell"; break;
        case 8: result = "Karplus-Strong Algorithm"; break;
        case 9: result = "White Noise"; break;
        case 10: result = "4 Sine"; break;
        case 11: result = "Repeating Narrow Pulse"; break;
        case 12: result = "Triangle (Time Domain Method)"; break;
        case 13: result = "Science Fiction Movie Sound"; break;
        case 14: result = "Non-string Karplus-Strong Sound"; break;
        case 15: result = "Sound 1 x Sound 1"; break;
        case 16: result = "Sound 1 x Sound 5"; break;
        case 17: result = "Sound 1 x Sound 10"; break;
        case 18: result = "Sound 4 x Sound 4"; break;
        case 19: result = "Sound 5 x Sound 6"; break;
        case 20: result = "Your Own Sound"; break;
        case 21: result = "Your Own Sound"; break;
        case 22: result = "Your Own Sound"; break;
        case 23: result = "Your Own Sound"; break;
        case 24: result = "Your Own Sound"; break;
    }

    for(int i = 0; i < postprocesses.length; ++i) {
        switch(postprocesses[i]) {
            case 1: result += ""; break;
            case 2: result += ", then Exponential Decay"; break;
            case 3: result += ", then Low Pass Filter"; break;
            case 4: result += ", then Band Reject Filter"; break;
            case 5: result += ", then Fade In"; break;
            case 6: result += ", then Reverse"; break;
            case 7: result += ", then Boost"; break;
            case 8: result += ", then Tremolo"; break;
            case 9: result += ", then Echo"; break;
        }
    }

    soundLabel.setText(result);
}

// This method handle the displayed post-processings
void updatePostprocessingInfo(Textlabel label, int postprocess) {
    switch(postprocess) {
        case 1: label.setText("No Post-Processing"); break;
        case 2: label.setText("Exponential Decay"); break;
        case 3: label.setText("Low Pass Filter"); break;
        case 4: label.setText("Band Reject Filter"); break;
        case 5: label.setText("Fade In"); break;
        case 6: label.setText("Reverse"); break;
        case 7: label.setText("Boost"); break;
        case 8: label.setText("Tremolo"); break;
        case 9: label.setText("Echo"); break;
    }
}

void regenerateSingleSound() {
    if(initializing || individualSoundWritten) return;

    writingSingleSound = true;

    if(masterAudioPlayer != null) {
        masterAudioPlayer.pause();
    }

    singleSoundSamples = soundGenerator.generateSound();

    for(int i = 0; i < postprocesses.length; ++i) {
        singleSoundSamples.applyPostProcessing(postprocesses[i]);
    }

    WAVFileWriter fw = new WAVFileWriter("currentsound.wav");
    fw.Save(singleSoundSamples.leftChannelSamples, singleSoundSamples.rightChannelSamples, samplingRate);
    if(showDebugMessages) {
        println(">>>  Finished saving sound... ");
    }
    masterAudioPlayer = minim.loadFile("currentsound.wav");

    writingSingleSound = false;
    individualSoundWritten = true;
}

// This method handle the GUI Control inputs
void controlEvent(ControlEvent theEvent) {
    if(writingSingleSound || writingSoundSequence || writingMusic) return;
    if(theEvent.isFrom(zoomInButton) || theEvent.isFrom(zoomOutButton)) return;

    if(masterAudioPlayer != null) {
        masterAudioPlayer.pause(); // Stop the currently playing sound, if any
    }

    if(theEvent.isFrom(frequencySelectionSlider)) {
        frequency = frequencySelectionSlider.getValue();
        frequencySelectionSlider.setValueLabel(Math.floor(frequencySelectionSlider.getValue() * 10) / 10 + " Hz");
        soundGenerator.setFrequency(frequency);
        individualSoundWritten = false;
    } else if (theEvent.isFrom(soundSelectionRadioButton)) {
        sound = int(theEvent.getGroup().getValue());
        soundGenerator.setSound(sound);
        updateSoundInfo();
        individualSoundWritten = false;
    } else {
        for(int i = 0; i < postprocesses.length; ++i) {
            if (theEvent.isFrom(postprocessSelectionRadioButton[i])) {
                postprocesses[i] = int(theEvent.getGroup().getValue());
                updateSoundInfo();
                updatePostprocessingInfo(postProcessingLabel[i], postprocesses[i]);
                individualSoundWritten = false;
                break;
            }
        }
    }

    // One thing at a time is better and only need to make the sound once
    if (!writingSingleSound && !writingSoundSequence && !writingMusic && !individualSoundWritten) {
        regenerateSingleSound();
    }
}

// Show the correct set of markers according to the number of channels
void setupAmplitudeMarkers(boolean twoChannels) {
    if(twoChannels) {
        oneBoth.hide();
        zeroBoth.hide();
        minusOneBoth.hide();
        oneLeft.show();
        zeroLeft.show();
        minusOneLeft.show();
        oneRight.show();
        zeroRight.show();
        minusOneRight.show();
        leftChannel.show();
        rightChannel.show();
    } else {
        oneBoth.show();
        zeroBoth.show();
        minusOneBoth.show();
        oneLeft.hide();
        zeroLeft.hide();
        minusOneLeft.hide();
        oneRight.hide();
        zeroRight.hide();
        minusOneRight.hide();
        leftChannel.hide();
        rightChannel.hide();
    }
}

// Draw a box surrounding
void drawBoundingBox() {
    noFill();
    stroke(255, 255, 255);
    rect(10, lowerBound + 40, soundControlWidth, soundControlHeight);
}

void drawTimeMarkers(float startPosition, boolean twoChannels, boolean drawAll) {
    if(twoChannels) {
        stroke(100, 100, 100);

        float lineCorrectionLeft = middle0Left;
        line(0, lineCorrectionLeft, width - 10, lineCorrectionLeft);
        line(0, lowerBoundLeft, width - 10, lowerBoundLeft);
        line(0, upperBoundLeft, width - 10, upperBoundLeft);

        float lineCorrectionRight = middle0Right;
        line(0, lineCorrectionRight, width - 10, lineCorrectionRight);
        line(0, lowerBoundRight, width - 10, lowerBoundRight);
        line(0, upperBoundRight, width - 10, upperBoundRight);

        line(width / 2, lowerBoundLeft, width / 2, lowerBoundLeft - 10);
        line(width / 4, lowerBoundLeft, width / 4, lowerBoundLeft - 10);
        line(width / 4 * 3, lowerBoundLeft, width / 4 * 3, lowerBoundLeft - 10);
        line(width / 2, upperBoundRight, width / 2, upperBoundRight + 10);
        line(width / 4, upperBoundRight, width / 4, upperBoundRight + 10);
        line(width / 4 * 3, upperBoundRight, width / 4 * 3, upperBoundRight + 10);

        fill(255, 255, 255);
        textSize(10);
        textAlign(LEFT);

        if(drawAll) {
            text(nf(0.0, 1, 3) + "s", 0, lowerBoundLeft + 11);
        } else {
            text(nf((startPosition) / samplingRate, 1, 3) + "s", 0, lowerBoundLeft + 11);
        }
        textAlign(CENTER);
        if(drawAll) {
            text(nf(musicDuration / 4.0, 1, 3) + "s", width / 4, lowerBoundLeft + 11);
            text(nf(musicDuration / 2.0) + "s", width / 2, lowerBoundLeft + 11);
            text(nf(musicDuration / 4.0 * 3) + "s", width / 4 * 3, lowerBoundLeft + 11);
        } else {
            text(nf((startPosition + (width / 4) * zoom) / samplingRate, 1, 3) + "s", width / 4, lowerBoundLeft + 11);
            text(nf((startPosition + (width / 2) * zoom) / samplingRate, 1, 3) + "s", width / 2, lowerBoundLeft + 11);
            text(nf((startPosition + (width / 4) * 3 * zoom) / samplingRate, 1, 3) + "s", width / 4 * 3, lowerBoundLeft + 11);
        }

    } else {
        stroke(100, 100, 100);

        float lineCorrection = middle0;
        line(0, lineCorrection, width - 10, lineCorrection);
        line(0, lowerBound, width - 10, lowerBound);
        line(0, upperBound, width - 10, upperBound);

        line(width / 2, lowerBound, width / 2, lowerBound - 10);
        line(width / 4, lowerBound, width / 4, lowerBound - 10);
        line(width / 4 * 3, lowerBound, width / 4 * 3, lowerBound - 10);
        fill(255, 255, 255);
        textSize(10);
        textAlign(LEFT);
        text(nf(startPosition / samplingRate, 1, 3) + "s", 0, lowerBound + 11);
        textAlign(CENTER);
        text(nf((startPosition + (width / 4) * zoom) / samplingRate, 1, 3) + "s", width / 4, lowerBound + 11);
        text(nf((startPosition + (width / 2) * zoom) / samplingRate, 1, 3) + "s", width / 2, lowerBound + 11);
        text(nf((startPosition + (width / 4) * 3 * zoom) / samplingRate, 1, 3) + "s", width / 4 * 3, lowerBound + 11);
    }
}

void drawWaveform(AudioSamples target, boolean twoChannels, int startPosition, boolean drawAll) {
    stroke(255, 255, 0);

    int step = zoom;
    if(drawAll) {
        step = 1;
        startPosition = 0;
    }
    int end = startPosition + width * step;
    if(drawAll) {
        end = target.totalSamples - step;
    }

    if(end > target.totalSamples - step) {
        end = target.totalSamples - step;
        startPosition = end - width * step;
    }

    if(startPosition < 0) {
        startPosition = 0;
    }

    if(twoChannels) {
        for(int i = startPosition; i < end; i += step) {
            float value1 = target.leftChannelSamples[i];
            if(value1 > maxValue) value1 = maxValue;
            if(value1 < minValue) value1 = minValue;

            float value2 = target.leftChannelSamples[i + step];
            if(value2 > maxValue) value2 = maxValue;
            if(value2 < minValue) value2 = minValue;

            line(float(i - startPosition) / (end - startPosition) * width, middle0Left - value1 * screenHeightHalf, float(i + 1 - startPosition) / (end - startPosition) * width, middle0Left - value2 * screenHeightHalf);

            value1 = target.rightChannelSamples[i];
            if(value1 > maxValue) value1 = maxValue;
            if(value1 < minValue) value1 = minValue;

            value2 = target.rightChannelSamples[i + step];
            if(value2 > maxValue) value2 = maxValue;
            if(value2 < minValue) value2 = minValue;

            line(float(i - startPosition) / (end - startPosition) * width, middle0Right - value1 * screenHeightHalf, float(i + 1 - startPosition) / (end - startPosition) * width, middle0Right - value2 * screenHeightHalf);
        }
    } else {
        // Draw the sample data (only the first 'width * zoom' samples, because of screen space))
        stroke(255, 255, 0);
        for(int i = startPosition; i < end; i += step) {
            float value1 = target.leftChannelSamples[i];
            if(value1 > maxValue) value1 = maxValue;
            if(value1 < minValue) value1 = minValue;

            float value2 = target.leftChannelSamples[i + step];
            if(value2 > maxValue) value2 = maxValue;
            if(value2 < minValue) value2 = minValue;

            line(float(i - startPosition) / (end - startPosition) * width, middle0 - value1 * screenHeight, float(i + 1 - startPosition) / (end - startPosition) * width, middle0 - value2 * screenHeight);
        }
    }

    drawTimeMarkers(startPosition, twoChannels, drawAll);
}

// This method will be called repeatedly
void draw() {
    AudioSamples target = singleSoundSamples;
    boolean twoChannels = false;
    boolean drawAll = false;
    int startPosition = 0;

    if(masterAudioPlayer == null || !masterAudioPlayer.isPlaying()) {
        playingSingleSound = false;
        playingSoundSequence = false;
        playingMusic = false;

        if(masterAudioPlayer.position() != 0) {
            individualSoundWritten = false;
            masterAudioPlayer.rewind();
        }
    }

    if (!writingSingleSound && !writingSoundSequence && !writingMusic && !individualSoundWritten) {
        regenerateSingleSound();
    }

    if(writingSoundSequence || playingSoundSequence) {
        target = soundSequenceSamples;
        twoChannels = true;
    } else if(writingMusic || playingMusic) {
        target = musicSamples;
        twoChannels = true;
    }

    if(writingSoundSequence || writingMusic) {
        drawAll = true;
    }

    if(playingSoundSequence) {
        soundLabel.setText(str(totalSoundGenerators) + " Generated Sounds");
    }

    if(writingMusic) {
        soundLabel.setText("Generating Music...");
    }

    if(playingMusic) {
        soundLabel.setText("MIDI Generated Music");
    }

    if(playingSingleSound || playingSoundSequence || playingMusic) {
        startPosition = int(masterAudioPlayer.position() / 1000.0 * samplingRate);
    }

    background(0, 0, 0); // Draw the background graphics, the origin is at the left top
    drawWaveform(target, twoChannels, startPosition, drawAll);
    drawBoundingBox();
    setupAmplitudeMarkers(twoChannels); // Show markers for one channels
}

void generateSoundSequence() {
    writingSoundSequence = true; // So other things don't interrupt the process

    // Reset audio samples before generating audio
    soundSequenceSamples.clear();

    if(showDebugMessages) {
        println();
        println(">>>  Please wait, creating best examples of all sounds and saving to WAV file 'allsounds.wav'...");
    }

    /*** complete this function ***/
    soundGenerator.generateSound(1, 1.0, 260, 5.0);
    AudioSamples samples = soundGenerator.getGeneratedSound();
    samples.applyPostProcessing(2); // Post-Process the sound (2 = exponential decay)
    samples.applyPostProcessing(7); // Post-Process the sound (7 = boost)
    soundSequenceSamples.add(samples, 0.0, 0.0);

    // Save the sound samples to a WAV file
    WAVFileWriter fw = new WAVFileWriter("allsounds.wav");
    fw.Save(soundSequenceSamples.leftChannelSamples, soundSequenceSamples.rightChannelSamples, samplingRate);

    if(showDebugMessages) {
        println(">>>  Finished generating and saving sound sequence... ");
        println(">>>  Start playing the generated sound sequence... ");
    }

    writingSoundSequence = false;
    playingSoundSequence = true;

    masterAudioPlayer = minim.loadFile("allsounds.wav");
    masterAudioPlayer.play();

    if(showDebugMessages) {
        println(">>>  Finished playing the genereated sound sequence... ");
    }

    if(showDebugMessages) {
        println(">>>  Have to re-Generate the single sound again to return it to what it was before... ");
    }
}

public void generateMusic(File selection) {
    if (selection != null) {
        writingMusic = true; // So other things don't interrupt the process

        String filePath = selection.getAbsolutePath();

        int[] sounds = {0, 1, 2};
        float[] vols = {0, 1, 1};
        int[][] pps = {
            {0, 0, 0}, {2, 0, 7}, {2, 9, 7}
        };
        float[] stereoPositions = {0, 0.7, 0.3};

        int startTime = 0; // Where to begin (in seconds)
        int endTime = 30; // Where to end (in seconds)

        // By default, the micro tempo is 50000 and hence the tempo is 120 (120 quarter note per minute).
        // The song "Let it go" has a tempo of 64.
        int microTempo = 93750; // Default: 50000 for tempo 120;
        int beatPerMinute = 6000000 / microTempo;
        float beatDuration = 60.0 / beatPerMinute;

        if(showDebugMessages) {
            println();
            println(">>>  Please wait, creating music sequence and saving to WAV file 'allmusic.wav'...");
        }

        File f = new File(filePath); // Load the selected MIDI file

        int generatingStartTime = millis();

        try {
            javax.sound.midi.Sequence MIDISequence = MidiSystem.getSequence(f); // Convert the loaded file into MIDI object

            int tickPerBeat = MIDISequence.getResolution();
            float tickDuration = beatDuration / tickPerBeat;

            // Get the tracks
            Track[] tracks = MIDISequence.getTracks();

            // Show some information before the generation starts
            if(showDebugMessages) {
                println("Music duration:" + MIDISequence.getMicrosecondLength() / 1000000 + "s");
                println("Tick per beat:" + tickPerBeat);
                println("Tick duration:" + tickDuration + "s");
                println("Number of tracks:" + tracks.length);
            }

            // Create a new MusicGenerator
            MusicGenerator musicGenerator = new MusicGenerator(MIDISequence.getTracks(), sounds, vols, pps, stereoPositions, startTime, endTime, tickDuration, samplingRate);
            Thread thread = new Thread(musicGenerator);
            thread.start();
            thread.join();

            int generatingDuration = millis() - generatingStartTime;
            println("Generated the music in " + generatingDuration / 1000.0 + "s");

            // After all the notes have been added at the correct starting times
            if(showDebugMessages) {
                println(">>>  Applying echo to the music sequence...");
            }

            // Add echo to the entire music
            musicSamples.applyPostProcessing(9);

            // You should consider using the 'boost' algorithm before/after applying the echo
            if(showDebugMessages) {
                println(">>>  Applying boost to the music sequence to fix clippings...");
            }

            // Lets boost the whole thing, so no clipping anywhere
            musicSamples.applyPostProcessing(7);

            if(showDebugMessages) {
                println(">>>  Finished boosting the music sequence...");
            }

            // Save the sound samples to a WAV file
            WAVFileWriter fw = new WAVFileWriter("allmusic.wav");
            fw.Save(musicSamples.leftChannelSamples, musicSamples.rightChannelSamples, samplingRate);

            if(showDebugMessages) {
                println(">>>  Finished generating and saving music sequence... ");
                println(">>>  Start playing the generated music sequence... ");
            }

            writingMusic = false;

            masterAudioPlayer = minim.loadFile("allmusic.wav");
            masterAudioPlayer.play();

            playingMusic = true;

            if(showDebugMessages) {
                println(">>>  Finished playing the genereated music sequence... ");
            }
        } catch(Exception e) {
            println(e);
        } finally {
            writingMusic = false;
        }
    }
}
